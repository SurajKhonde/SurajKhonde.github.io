{"status":"ok","feed":{"url":"https://medium.com/feed/@surajrkhonde","title":"Stories by Suraj Khonde on Medium","link":"https://medium.com/@surajrkhonde?source=rss-c76fad0a4dd3------2","author":"","description":"Stories by Suraj Khonde on Medium","image":"https://cdn-images-1.medium.com/fit/c/150/150/0*YkYC7rd14B1WBshZ"},"items":[{"title":"From Stalling on First Gear to Cruising with Vite: A Beginner-Friendly React Setup","pubDate":"2025-08-17 14:30:30","link":"https://medium.com/@surajrkhonde/from-stalling-on-first-gear-to-cruising-with-vite-a-beginner-friendly-react-setup-9bc0f824e6c6?source=rss-c76fad0a4dd3------2","guid":"https://medium.com/p/9bc0f824e6c6","author":"Suraj Khonde","thumbnail":"","description":"\n<p>I still remember learning to ride a bike\u200a\u2014\u200afoot on the pedal, heart in my throat. Then came a motorbike: clutch, first gear, stall. Repeat. Painful at first\u2026 until one day it clicked, and everything felt automatic. Learning modern web tooling can feel the same way. Docs look giant, acronyms fly everywhere, and your brain just wants a simple path that \u201cworks.\u201d So today, let\u2019s skip the stall and cruise straight into React using <strong>Vite</strong>\u200a\u2014\u200afast, simple, and very beginner-friendly.</p>\n<h3>Why Vite? (3 hot\u00a0points)</h3>\n<p><strong>1.Instant dev server + HMR</strong><br> Starts in a flash and updates the browser instantly when you save. No more waiting\u00a0around.</p>\n<p><strong>2.Optimized builds out of the box</strong><br> Uses Rollup under the hood for production\u200a\u2014\u200atree-shaking, code-splitting, and great output\u00a0sizes.</p>\n<p><strong>3.DX that doesn\u2019t fight you</strong><br> First-class TypeScript, JSX, env files, aliases, PostCSS, and a rich plugin ecosystem.</p>\n<h4>Quick Start (the exact commands)</h4>\n<pre># JavaScript template<br>npm create vite@latest my-react-app -- --template react<br><br># TypeScript template<br>npm create vite@latest my-react-app -- --template react-ts</pre>\n<h4>Then install &amp;\u00a0run:</h4>\n<pre>cd my-react-app<br>npm install<br>npm run dev</pre>\n<p>You\u2019ll see something like:<br> Local: http://localhost:5173 \u2192 open\u00a0it!</p>\n<h3>What you get (without reading a ton of\u00a0docs)</h3>\n<ul>\n<li>A minimal React (or React + TS) project that <strong>just\u00a0runs</strong>\n</li>\n<li>Lightning-fast refresh when you hit save (thanks,\u00a0HMR)</li>\n<li>A production build that\u2019s already optimized</li>\n</ul>\n<h3>Setting up Tailwind CSS in Vite +\u00a0React</h3>\n<pre>npm install tailwindcss @tailwindcss/vite</pre>\n<h4>vite.config.ts</h4>\n<pre>import { defineConfig } from 'vite'<br>import tailwindcss from '@tailwindcss/vite'<br>export default defineConfig({<br>  plugins: [<br>    tailwindcss(),<br>  ],<br>})</pre>\n<h4>Import Tailwind\u00a0CSS</h4>\n<p>In index.css replace all code\u00a0with</p>\n<pre>@import \"tailwindcss\";</pre>\n<p>vite.config.ts need to update to\u00a0This</p>\n<pre>import { defineConfig } from 'vite'<br>import react from '@vitejs/plugin-react'<br>import tailwindcss from '@tailwindcss/vite'<br>export default defineConfig({<br>  plugins: [ tailwindcss(),react()],<br>})</pre>\n<p>now time add to extension which helps Autocomplete style</p>\n<p><strong>Tailwind CSS IntelliSense (extension)</strong></p>\n<p>want react Autosuggestion</p>\n<p>install dev dependencies</p>\n<pre>npm install @types/react</pre>\n<h3>Wrapping Up: From Stalls to Smooth\u00a0Rides</h3>\n<p>If learning React + Vite + Tailwind felt like kicking a bike into first gear, congratulations\u200a\u2014\u200ayou just shifted smoothly into second without stalling\u00a0\ud83c\udf89.</p>\n<p>Remember:</p>\n<ul>\n<li>Don\u2019t fear the docs (they\u2019re the traffic signs, not the traffic\u00a0jam).</li>\n<li>Vite is your turbo engine\u00a0\ud83c\udfcd\ufe0f.</li>\n<li>Tailwind is your stylish helmet\u200a\u2014\u200ayou\u2019ll look good while coding\u00a0safe.</li>\n</ul>\n<p>And just like riding, the first few tries may feel jerky, but soon your fingers will shift between npm run dev and npm run build like second\u00a0nature.</p>\n<p>So keep cruising\u200a\u2014\u200athe web dev highway is long, the pit stops are many, and your React apps are about to look <em>fresh and\u00a0fast</em>.</p>\n<p>Now go ride that code like a pro\u00a0\ud83c\udfc1\u2728.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=9bc0f824e6c6\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<p>I still remember learning to ride a bike\u200a\u2014\u200afoot on the pedal, heart in my throat. Then came a motorbike: clutch, first gear, stall. Repeat. Painful at first\u2026 until one day it clicked, and everything felt automatic. Learning modern web tooling can feel the same way. Docs look giant, acronyms fly everywhere, and your brain just wants a simple path that \u201cworks.\u201d So today, let\u2019s skip the stall and cruise straight into React using <strong>Vite</strong>\u200a\u2014\u200afast, simple, and very beginner-friendly.</p>\n<h3>Why Vite? (3 hot\u00a0points)</h3>\n<p><strong>1.Instant dev server + HMR</strong><br> Starts in a flash and updates the browser instantly when you save. No more waiting\u00a0around.</p>\n<p><strong>2.Optimized builds out of the box</strong><br> Uses Rollup under the hood for production\u200a\u2014\u200atree-shaking, code-splitting, and great output\u00a0sizes.</p>\n<p><strong>3.DX that doesn\u2019t fight you</strong><br> First-class TypeScript, JSX, env files, aliases, PostCSS, and a rich plugin ecosystem.</p>\n<h4>Quick Start (the exact commands)</h4>\n<pre># JavaScript template<br>npm create vite@latest my-react-app -- --template react<br><br># TypeScript template<br>npm create vite@latest my-react-app -- --template react-ts</pre>\n<h4>Then install &amp;\u00a0run:</h4>\n<pre>cd my-react-app<br>npm install<br>npm run dev</pre>\n<p>You\u2019ll see something like:<br> Local: http://localhost:5173 \u2192 open\u00a0it!</p>\n<h3>What you get (without reading a ton of\u00a0docs)</h3>\n<ul>\n<li>A minimal React (or React + TS) project that <strong>just\u00a0runs</strong>\n</li>\n<li>Lightning-fast refresh when you hit save (thanks,\u00a0HMR)</li>\n<li>A production build that\u2019s already optimized</li>\n</ul>\n<h3>Setting up Tailwind CSS in Vite +\u00a0React</h3>\n<pre>npm install tailwindcss @tailwindcss/vite</pre>\n<h4>vite.config.ts</h4>\n<pre>import { defineConfig } from 'vite'<br>import tailwindcss from '@tailwindcss/vite'<br>export default defineConfig({<br>  plugins: [<br>    tailwindcss(),<br>  ],<br>})</pre>\n<h4>Import Tailwind\u00a0CSS</h4>\n<p>In index.css replace all code\u00a0with</p>\n<pre>@import \"tailwindcss\";</pre>\n<p>vite.config.ts need to update to\u00a0This</p>\n<pre>import { defineConfig } from 'vite'<br>import react from '@vitejs/plugin-react'<br>import tailwindcss from '@tailwindcss/vite'<br>export default defineConfig({<br>  plugins: [ tailwindcss(),react()],<br>})</pre>\n<p>now time add to extension which helps Autocomplete style</p>\n<p><strong>Tailwind CSS IntelliSense (extension)</strong></p>\n<p>want react Autosuggestion</p>\n<p>install dev dependencies</p>\n<pre>npm install @types/react</pre>\n<h3>Wrapping Up: From Stalls to Smooth\u00a0Rides</h3>\n<p>If learning React + Vite + Tailwind felt like kicking a bike into first gear, congratulations\u200a\u2014\u200ayou just shifted smoothly into second without stalling\u00a0\ud83c\udf89.</p>\n<p>Remember:</p>\n<ul>\n<li>Don\u2019t fear the docs (they\u2019re the traffic signs, not the traffic\u00a0jam).</li>\n<li>Vite is your turbo engine\u00a0\ud83c\udfcd\ufe0f.</li>\n<li>Tailwind is your stylish helmet\u200a\u2014\u200ayou\u2019ll look good while coding\u00a0safe.</li>\n</ul>\n<p>And just like riding, the first few tries may feel jerky, but soon your fingers will shift between npm run dev and npm run build like second\u00a0nature.</p>\n<p>So keep cruising\u200a\u2014\u200athe web dev highway is long, the pit stops are many, and your React apps are about to look <em>fresh and\u00a0fast</em>.</p>\n<p>Now go ride that code like a pro\u00a0\ud83c\udfc1\u2728.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=9bc0f824e6c6\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["react","frontend","tailwind-css","vites"]},{"title":"Search is not just UI\u200a\u2014\u200ait\u2019s a performance-critical feature.","pubDate":"2025-08-16 04:51:52","link":"https://medium.com/@surajrkhonde/search-is-not-just-ui-its-a-performance-critical-feature-06c4748d5e87?source=rss-c76fad0a4dd3------2","guid":"https://medium.com/p/06c4748d5e87","author":"Suraj Khonde","thumbnail":"","description":"\n<h3><strong>Search is not just UI\u200a\u2014\u200ait\u2019s a performance-critical feature.</strong></h3>\n<figure><img alt=\"search\" src=\"https://cdn-images-1.medium.com/max/1024/0*9hKO7B8PKGN1-xel\"><figcaption>Photo by <a href=\"https://unsplash.com/@evgenit?utm_source=medium&amp;utm_medium=referral\">Evgeni Tcherkasski</a> on\u00a0<a href=\"https://unsplash.com/?utm_source=medium&amp;utm_medium=referral\">Unsplash</a></figcaption></figure><p>Search is one of the most critical user experiences in any digital product. From typing a query into Google, to finding a product on Amazon, to looking up a teammate in Slack\u200a\u2014\u200awe\u2019re constantly searching. Behind the scenes, it\u2019s not just about matching strings\u200a\u2014\u200ait\u2019s about doing it <em>fast</em> across thousands (or millions) of records, often in unordered and unpredictable datasets. And trust me, when you need real-time results in milliseconds, building an efficient search algorithm becomes a serious challenge.</p>\n<p>&gt;how search works under the hood and how you can build your own blazing-fast search logic in **JavaScript with React**\u200a\u2014\u200awithout relying on heavyweight libraries.</p>\n<p>How Search Works (Conceptually)<br>- <strong>Linear Search\u00a0</strong>: Check each record one by one\u200a\u2014\u200asimple but slow for big data.<br>- <strong>Binary Search</strong>: Only works on sorted data; very fast (`O(log n)`) but requires structure.<br>- <strong>Fuzzy Search</strong>: Handles typos, near matches, and word reordering (like Google does).<br>- <strong>Tries / Indexes</strong>: Special data structures for prefix-based or dictionary-like searches.<br><em>In a real-world React app, we often deal with unordered JSON data\u200a\u2014\u200amaking linear or indexed search the go-to strategies.</em></p>\n<h4>Simple Search with\u00a0.filter() and\u00a0.includes()</h4>\n<pre>function search(data, query) {<br>  const lower = query.toLowerCase();<br>  return data.filter(item =&gt; {<br>    const fullName = `${item.firstName} ${item.lastName}`.toLowerCase();<br>    return fullName.includes(lower);<br>  });<br>}</pre>\n<p>- Works for case-insensitive, partial string matches<br>- No ranking or typo tolerance<br>- Time complexity: O(n)\u200a\u2014\u200alinear but fast for &lt;10k\u00a0records</p>\n<h4>Step 2: Hook It Up in\u00a0React</h4>\n<pre>import React, { useState, useMemo } from 'react';<br><br>function UserSearch({ users }) {<br>  const [query, setQuery] = useState('');<br><br>  const results = useMemo(() =&gt; {<br>    return users.filter(user =&gt; {<br>      const fullName = `${user.firstName} ${user.lastName}`.toLowerCase();<br>      return fullName.includes(query.toLowerCase());<br>    });<br>  }, [query, users]);<br>  return (<br>    &lt;div&gt;<br>      &lt;input<br>        type=\"text\"<br>        placeholder=\"Search users...\"<br>        value={query}<br>        onChange={e =&gt; setQuery(e.target.value)}<br>      /&gt;<br>      &lt;ul&gt;<br>        {results.map(user =&gt; (<br>          &lt;li key={user.id}&gt;{user.firstName} {user.lastName}&lt;/li&gt;<br>        ))}<br>      &lt;/ul&gt;<br>    &lt;/div&gt;<br>  );<br>}</pre>\n<h4>Build Your Own Search Index with\u00a0Map</h4>\n<pre>const userMap = new Map();<br>const nameIndex = [];<br><br>for (const user of users) {<br>  userMap.set(user.id, user);<br>  nameIndex.push({<br>    id: user.id,<br>    fullName: `${user.firstName} ${user.lastName}`.toLowerCase()<br>  });<br>}<br><br>function searchIndex(query) {<br>  return nameIndex<br>    .filter(entry =&gt; entry.fullName.includes(query.toLowerCase()))<br>    .map(entry =&gt; userMap.get(entry.id));<br>}</pre>\n<ul>\n<li>`Map` gives you `O(1)` lookup by\u00a0ID</li>\n<li>Index array keeps things fast and searchable</li>\n<li>const userMap = new\u00a0Map();</li>\n<li>You create a `Map` where keys will be `user.id` and values will be the full user\u00a0object.</li>\n<li>`Map` gives **O(1)** lookup speed by ID\u200a\u2014\u200away faster than `.find()` on an\u00a0array.</li>\n<li>const nameIndex =\u00a0[];</li>\n<li>This is your search index\u200a\u2014\u200aan array of simplified searchable entries (`id` + `fullName`).</li>\n</ul>\n<pre>for (const user of users) {<br>  userMap.set(user.id, user);<br>  nameIndex.push({<br>    id: user.id,<br>    fullName: `${user.firstName} ${user.lastName}`.toLowerCase()<br>  });<br>}</pre>\n<h4>If `users`\u00a0is:</h4>\n<pre>[<br>  { id: 1, firstName: \"Alice\", lastName: \"Wong\" },<br>  { id: 2, firstName: \"Bob\", lastName: \"Smith\" }<br>]</pre>\n<h4>Then:</h4>\n<h4>userMap becomes:</h4>\n<pre>Map {<br>  1 =&gt; { id: 1, firstName: \"Alice\", lastName: \"Wong\" },<br>  2 =&gt; { id: 2, firstName: \"Bob\", lastName: \"Smith\" }<br>}</pre>\n<h4>`nameIndex` becomes:</h4>\n<pre>[<br>  { id: 1, fullName: \"alice wong\" },<br>  { id: 2, fullName: \"bob smith\" }<br>]<br>function searchIndex(query) {<br>  return nameIndex<br>    .filter(entry =&gt; entry.fullName.includes(query.toLowerCase()))<br>    .map(entry =&gt; userMap.get(entry.id));<br>}</pre>\n<h4>Add Fuzzy Search with `Fuse.js`</h4>\n<pre>import Fuse from 'fuse.js';<br>const fuse = new Fuse(users, {<br>  keys: ['firstName', 'lastName'],<br>  threshold: 0.3,<br>});<br>const results = fuse.search('ali')</pre>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=06c4748d5e87\" width=\"1\" height=\"1\" alt=\"\">\n","content":"\n<h3><strong>Search is not just UI\u200a\u2014\u200ait\u2019s a performance-critical feature.</strong></h3>\n<figure><img alt=\"search\" src=\"https://cdn-images-1.medium.com/max/1024/0*9hKO7B8PKGN1-xel\"><figcaption>Photo by <a href=\"https://unsplash.com/@evgenit?utm_source=medium&amp;utm_medium=referral\">Evgeni Tcherkasski</a> on\u00a0<a href=\"https://unsplash.com/?utm_source=medium&amp;utm_medium=referral\">Unsplash</a></figcaption></figure><p>Search is one of the most critical user experiences in any digital product. From typing a query into Google, to finding a product on Amazon, to looking up a teammate in Slack\u200a\u2014\u200awe\u2019re constantly searching. Behind the scenes, it\u2019s not just about matching strings\u200a\u2014\u200ait\u2019s about doing it <em>fast</em> across thousands (or millions) of records, often in unordered and unpredictable datasets. And trust me, when you need real-time results in milliseconds, building an efficient search algorithm becomes a serious challenge.</p>\n<p>&gt;how search works under the hood and how you can build your own blazing-fast search logic in **JavaScript with React**\u200a\u2014\u200awithout relying on heavyweight libraries.</p>\n<p>How Search Works (Conceptually)<br>- <strong>Linear Search\u00a0</strong>: Check each record one by one\u200a\u2014\u200asimple but slow for big data.<br>- <strong>Binary Search</strong>: Only works on sorted data; very fast (`O(log n)`) but requires structure.<br>- <strong>Fuzzy Search</strong>: Handles typos, near matches, and word reordering (like Google does).<br>- <strong>Tries / Indexes</strong>: Special data structures for prefix-based or dictionary-like searches.<br><em>In a real-world React app, we often deal with unordered JSON data\u200a\u2014\u200amaking linear or indexed search the go-to strategies.</em></p>\n<h4>Simple Search with\u00a0.filter() and\u00a0.includes()</h4>\n<pre>function search(data, query) {<br>  const lower = query.toLowerCase();<br>  return data.filter(item =&gt; {<br>    const fullName = `${item.firstName} ${item.lastName}`.toLowerCase();<br>    return fullName.includes(lower);<br>  });<br>}</pre>\n<p>- Works for case-insensitive, partial string matches<br>- No ranking or typo tolerance<br>- Time complexity: O(n)\u200a\u2014\u200alinear but fast for &lt;10k\u00a0records</p>\n<h4>Step 2: Hook It Up in\u00a0React</h4>\n<pre>import React, { useState, useMemo } from 'react';<br><br>function UserSearch({ users }) {<br>  const [query, setQuery] = useState('');<br><br>  const results = useMemo(() =&gt; {<br>    return users.filter(user =&gt; {<br>      const fullName = `${user.firstName} ${user.lastName}`.toLowerCase();<br>      return fullName.includes(query.toLowerCase());<br>    });<br>  }, [query, users]);<br>  return (<br>    &lt;div&gt;<br>      &lt;input<br>        type=\"text\"<br>        placeholder=\"Search users...\"<br>        value={query}<br>        onChange={e =&gt; setQuery(e.target.value)}<br>      /&gt;<br>      &lt;ul&gt;<br>        {results.map(user =&gt; (<br>          &lt;li key={user.id}&gt;{user.firstName} {user.lastName}&lt;/li&gt;<br>        ))}<br>      &lt;/ul&gt;<br>    &lt;/div&gt;<br>  );<br>}</pre>\n<h4>Build Your Own Search Index with\u00a0Map</h4>\n<pre>const userMap = new Map();<br>const nameIndex = [];<br><br>for (const user of users) {<br>  userMap.set(user.id, user);<br>  nameIndex.push({<br>    id: user.id,<br>    fullName: `${user.firstName} ${user.lastName}`.toLowerCase()<br>  });<br>}<br><br>function searchIndex(query) {<br>  return nameIndex<br>    .filter(entry =&gt; entry.fullName.includes(query.toLowerCase()))<br>    .map(entry =&gt; userMap.get(entry.id));<br>}</pre>\n<ul>\n<li>`Map` gives you `O(1)` lookup by\u00a0ID</li>\n<li>Index array keeps things fast and searchable</li>\n<li>const userMap = new\u00a0Map();</li>\n<li>You create a `Map` where keys will be `user.id` and values will be the full user\u00a0object.</li>\n<li>`Map` gives **O(1)** lookup speed by ID\u200a\u2014\u200away faster than `.find()` on an\u00a0array.</li>\n<li>const nameIndex =\u00a0[];</li>\n<li>This is your search index\u200a\u2014\u200aan array of simplified searchable entries (`id` + `fullName`).</li>\n</ul>\n<pre>for (const user of users) {<br>  userMap.set(user.id, user);<br>  nameIndex.push({<br>    id: user.id,<br>    fullName: `${user.firstName} ${user.lastName}`.toLowerCase()<br>  });<br>}</pre>\n<h4>If `users`\u00a0is:</h4>\n<pre>[<br>  { id: 1, firstName: \"Alice\", lastName: \"Wong\" },<br>  { id: 2, firstName: \"Bob\", lastName: \"Smith\" }<br>]</pre>\n<h4>Then:</h4>\n<h4>userMap becomes:</h4>\n<pre>Map {<br>  1 =&gt; { id: 1, firstName: \"Alice\", lastName: \"Wong\" },<br>  2 =&gt; { id: 2, firstName: \"Bob\", lastName: \"Smith\" }<br>}</pre>\n<h4>`nameIndex` becomes:</h4>\n<pre>[<br>  { id: 1, fullName: \"alice wong\" },<br>  { id: 2, fullName: \"bob smith\" }<br>]<br>function searchIndex(query) {<br>  return nameIndex<br>    .filter(entry =&gt; entry.fullName.includes(query.toLowerCase()))<br>    .map(entry =&gt; userMap.get(entry.id));<br>}</pre>\n<h4>Add Fuzzy Search with `Fuse.js`</h4>\n<pre>import Fuse from 'fuse.js';<br>const fuse = new Fuse(users, {<br>  keys: ['firstName', 'lastName'],<br>  threshold: 0.3,<br>});<br>const results = fuse.search('ali')</pre>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=06c4748d5e87\" width=\"1\" height=\"1\" alt=\"\">\n","enclosure":{},"categories":["search-algorithm","reactjs","react"]}]}